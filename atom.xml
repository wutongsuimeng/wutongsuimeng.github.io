<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wutongsuimeng.github.io</id>
    <title>梧桐碎梦</title>
    <updated>2020-11-22T11:02:27.859Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wutongsuimeng.github.io"/>
    <link rel="self" href="https://wutongsuimeng.github.io/atom.xml"/>
    <subtitle>好好学习</subtitle>
    <logo>https://wutongsuimeng.github.io/images/avatar.png</logo>
    <icon>https://wutongsuimeng.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 梧桐碎梦</rights>
    <entry>
        <title type="html"><![CDATA[使用RaiDrive在window平台上挂载google drive]]></title>
        <id>https://wutongsuimeng.github.io/post/shi-yong-raidrive-zai-window-ping-tai-shang-gua-zai-google-drive/</id>
        <link href="https://wutongsuimeng.github.io/post/shi-yong-raidrive-zai-window-ping-tai-shang-gua-zai-google-drive/">
        </link>
        <updated>2020-11-22T09:47:25.000Z</updated>
        <content type="html"><![CDATA[<p>1.在raidrive界面添加google drive即可<br>
<img src="https://wutongsuimeng.github.io/post-images/1606038544555.png" alt="" loading="lazy"><br>
2.因为raidrive不支持sock5，即在使用ssr进行科学上网时，会显示挂载失败，所以这里建议使用55tap，因为55tap早已经停止更新，所以提供了某大佬的下载地址https://down.moerats.com/55Tap/。(地址已失效)<br>
3.将55tap的模式选择为不代理中国ip，并添加一个ss/ssr代理。保存并使用即可。<br>
<img src="https://wutongsuimeng.github.io/post-images/1606038564871.png" alt="" loading="lazy"><br>
<img src="https://wutongsuimeng.github.io/post-images/1606038608069.png" alt="" loading="lazy"><br>
4.保存激活即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[修复grub引导]]></title>
        <id>https://wutongsuimeng.github.io/post/xiu-fu-grub-yin-dao/</id>
        <link href="https://wutongsuimeng.github.io/post/xiu-fu-grub-yin-dao/">
        </link>
        <updated>2020-11-22T09:43:15.000Z</updated>
        <content type="html"><![CDATA[<p>linux引导报错,在启动linux时,进入了grub rescue.<br>
修复步骤:</p>
<pre><code>1.确定系统的boot分区,我的在(hd0,gpt6),用ls查看
2.root=(hd0,gpt6)
3.确定boot分区是单独分区还是不单独分区
单独分区:prefix=(hd0,gpt6)/grub
不单独分区:prefix=(hd0,gpt6)/boot/grub
4.insmod normal
5.normal
通过以上步骤便能进入系统
6.进入系统后,要进行grub的修复
sudo update-grub
7.sudo grub-install /dev/sda
(sda表示的是你的硬盘号码,不要指定号码,例如sda1之类的)
</code></pre>
<p>注:在grub rescue下,用ls root可以查看boot分区;<br>
如果不知道哪个是boot分区,可以一个一个分区找,例如ls (hd0,gpt6),找到文件系统是ext2的.如果/boot不是单独分区,则用ls (hd0,gpt6)/boot找是否存在这个文件夹;如果是单独分区 ,则可以用ls (hd0,gpt6)/grub找,如果出现了grub.cfg的文件,则证明找到了boot分区</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[启动vue应用]]></title>
        <id>https://wutongsuimeng.github.io/post/qi-dong-vue-ying-yong/</id>
        <link href="https://wutongsuimeng.github.io/post/qi-dong-vue-ying-yong/">
        </link>
        <updated>2020-11-22T09:37:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-使用可视化启动应用">一. 使用可视化启动应用</h1>
<p>在cmd输入命令<code>vue ui</code>启动vue可视化界面。</p>
<p>在任务的serve的运行启动应用。</p>
<figure data-type="image" tabindex="1"><img src="https://wutongsuimeng.github.io/post-images/1606038052307.png" alt="" loading="lazy"></figure>
<h1 id="二-使用命令行启动">二. 使用命令行启动</h1>
<p>在含有node_modules目录的目录下打开cmd，使用命令<code>npm run serve</code></p>
<figure data-type="image" tabindex="2"><img src="https://wutongsuimeng.github.io/post-images/1606038093326.png" alt="" loading="lazy"></figure>
<h1 id="三-启动应用时碰到的问题">三. 启动应用时碰到的问题</h1>
<h2 id="1-报错npm-err-missing-scriptdev">1. 报错<code>npm ERR! missing script:dev</code></h2>
<p>因为是直接git下来的项目，所以直接去运行<code>npm run dev</code>命令时报错：</p>
<p><code>npm ERR! missing script:dev</code></p>
<p>**解决：**去看文件package.json，文件有如下代码：</p>
<pre><code>  &quot;scripts&quot;: {    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,    &quot;build&quot;: &quot;vue-cli-service build&quot;  },
</code></pre>
<p>看到并没有dev，所以才会报错，但是可以使用serve，所以再次在目录运行命令<code>npm run serve</code>，便运行成功了。</p>
<figure data-type="image" tabindex="3"><img src="https://wutongsuimeng.github.io/post-images/1606038122865.png" alt="" loading="lazy"></figure>
<h2 id="2-报错npm-报错npm-err-missing-script-start-npm-err-a-complete-log-of-this-run-can-be-found-in-npm-err">2. 报错<code>npm 报错：npm ERR! missing script: start npm ERR! A complete log of this run can be found in: npm ERR!</code></h2>
<p>去看了一下，发现目录下没有node_modules目录，所以需要重新运行命令<code>cnpm install</code>和<code>cnpm run build</code>命令，重新安装依赖模块，生成node_modules目录和dist目录。</p>
<h2 id="3-报错error-while-running-taskwith-messagespawn-vue-cli-service-enoent">3. 报错<code>Error while running taskwith message'spawn vue-cli-service ENOENT'</code></h2>
<p>把node_modules目录删除，重新生成依赖模块。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用JavaMail发送邮件]]></title>
        <id>https://wutongsuimeng.github.io/post/shi-yong-javamail-fa-song-you-jian/</id>
        <link href="https://wutongsuimeng.github.io/post/shi-yong-javamail-fa-song-you-jian/">
        </link>
        <updated>2020-11-22T09:35:38.000Z</updated>
        <content type="html"><![CDATA[<p>javaMail提供了发送邮件所需的api。</p>
<p>本文使用freemarker创建邮件模板。</p>
<h1 id="引入依赖">引入依赖</h1>
<pre><code class="language-xml">	&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h1 id="在applicationyml中配置发送邮件信息">在application.yml中配置发送邮件信息</h1>
<p>不建议使用outlook邮箱，因为会报错并导致outlook邮箱被锁定。需要手机验证解绑定。</p>
<p>使用新浪邮箱需要打开stmp服务，地址为smtp.163.com，端口为25。其他邮箱类似，其中qq邮箱需要授权码代替密码使用。</p>
<p>username是登录时使用的用户名，不一定是邮箱地址。</p>
<pre><code class="language-yaml">spring:
  mail:
    host: smtp.163.com
    port: 25
    protocol: smtp
    username: xxx
    password: xxx
    default-encoding: utf-8
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
</code></pre>
<h2 id="可能会导致的错误消息">可能会导致的错误消息：</h2>
<h3 id="1-smtpsmtpsendfailedexception-553-mail-from-must-equal-authorized-user">1. smtp.SMTPSendFailedException: 553 Mail from must equal authorized user</h3>
<p>解决：需要登录邮箱的用户与发信人一致。意思是</p>
<pre><code class="language-java">helper.setFrom(&quot;xxx&quot;); 要与你配置的用户电子邮件一致
</code></pre>
<h3 id="2-javaxmailauthenticationfailedexception-535-573-authentication-unsuccessful">2. javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful</h3>
<p>意思是用户名或密码错误。</p>
<h1 id="使用freemarker创建邮件模板">使用freemarker创建邮件模板</h1>
<p>新建一个ftl文件，放在了resources/static/ftl目录下，命名为employee.ftl。</p>
<p>可以使用html代码编写，使用${}表示动态指令，能随时更新。</p>
<pre><code class="language-html">&lt;p&gt;你好，${name}同学，恭喜你加入本公司，这是你的工作id${workID}&lt;/p&gt;
</code></pre>
<p>使用setClassLoaderForTemplateLoading设置模板文件地址</p>
<p>getTemplate用来获取模板</p>
<pre><code class="language-java">Configuration cfg=new Configuration(Configuration.VERSION_2_3_0); //新建一个配置
cfg.setClassLoaderForTemplateLoading(ClassLoader.getSystemClassLoader(),&quot;static/ftl/&quot;);
Template emailTemplate=cfg.getTemplate(&quot;employee.ftl&quot;);
</code></pre>
<h1 id="创建电子邮件并发送">创建电子邮件并发送</h1>
<p>注入JavaMailSender</p>
<pre><code class="language-java">@Autowired
private JavaMailSender mailSender;
</code></pre>
<pre><code class="language-java">Map&lt;String,Object&gt; model=new HashMap&lt;&gt;();
model.put(&quot;name&quot;,employee.getName());
model.put(&quot;workID&quot;,employee.getWorkID());

MimeMessage mimeMessage=mailSender.createMimeMessage();
MimeMessageHelper helper=new MimeMessageHelper(mimeMessage,true);
helper.setFrom(&quot;xxx&quot;); //设置发信人地址
helper.setTo(employee.getEmail()); //收信人地址
helper.setSubject(&quot;入职书&quot;);  //设置主题
helper.setText(&quot;入职书&quot;, FreeMarkerTemplateUtils.processTemplateIntoString(emailTemplate,model)); //设置邮件内容
mailSender.send(mimeMessage); //发送邮件
</code></pre>
<h1 id="完整代码">完整代码</h1>
<h2 id="service层">Service层</h2>
<pre><code class="language-java">import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.springframework.ui.freemarker.FreeMarkerTemplateUtils;

import javax.mail.MessagingException;
import javax.mail.internet.MimeMessage;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Service(&quot;EmailService&quot;)
public class EmailService {

    @Autowired
    private JavaMailSender mailSender;

    public void send(Employee employee) throws IOException, MessagingException, TemplateException {
        Configuration cfg=new Configuration(Configuration.VERSION_2_3_0);
        cfg.setClassLoaderForTemplateLoading(ClassLoader.getSystemClassLoader(),&quot;static/ftl/&quot;);
        Template emailTemplate=cfg.getTemplate(&quot;employee.ftl&quot;);

        Map&lt;String,Object&gt; model=new HashMap&lt;&gt;();
        model.put(&quot;name&quot;,employee.getName());
        model.put(&quot;workID&quot;,employee.getWorkID());

        MimeMessage mimeMessage=mailSender.createMimeMessage();
        MimeMessageHelper helper=new MimeMessageHelper(mimeMessage,true);
        helper.setFrom(&quot;xxx&quot;);
        helper.setTo(employee.getEmail());
        helper.setSubject(&quot;入职书&quot;);
        helper.setText(&quot;入职书&quot;, FreeMarkerTemplateUtils.processTemplateIntoString(emailTemplate,model));
        mailSender.send(mimeMessage);
    }
}

</code></pre>
<h2 id="controller层">Controller层</h2>
<pre><code class="language-java">@Resource
private EmailService emailService;

emailService.send(employee);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Calendar类]]></title>
        <id>https://wutongsuimeng.github.io/post/calendar-lei/</id>
        <link href="https://wutongsuimeng.github.io/post/calendar-lei/">
        </link>
        <updated>2020-11-22T09:32:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-calendargetinstance">1. Calendar.getInstance()</h1>
<p>获取当前Calendar对象实例</p>
<h1 id="2-addint-field-int-amount">2. add(int field, int amount)</h1>
<p>field是指需要获取的字段的值，对field根据当前日历增加或减少amount。</p>
<p>field分为：</p>
<p>YEAR 年</p>
<p>MONTH 月( 0 到 11)</p>
<p>WEEK_OF_YEAR 一年周数</p>
<p>WEEK_OF_MONTH 一个月周数</p>
<p>DAY_OF_MONTH 一个月天数，从1开始</p>
<p>DAY_OF_YEAR 一年的天数</p>
<p>。。。</p>
<p>例如：</p>
<pre><code class="language-java">Calendar c=Calendar.getInstance();
c.add(Calendar.MONTH,1); //会在当前日期的月增加1，例如当前是7月，那么就会输出8月
Date d=c.getTime();
</code></pre>
<h1 id="3-setint-field-int-value">3. set(int field, int value)</h1>
<p>设置field为value，其他不变。</p>
<p>例如：</p>
<pre><code class="language-java">Calendar c=Calendar.getInstance();
c.set(Calendar.MONTH,1); //将当前日期的月设置为1，例如现在是Sun **Jul** 12 15:19:47 CST 2020，那么将会输出Wed **Feb** 12 15:19:47 CST 2020
Date d=c.getTime();
</code></pre>
<h1 id="4-getint-field">4. get(int field)</h1>
<p>获取当前field的值。</p>
<pre><code class="language-java">c.get(Calendar.MONTH); //返回当前月数，例如现在是7月，那返回6
</code></pre>
<h1 id="5-gettime">5. getTime()</h1>
<p>返回一个Date属性。</p>
<h1 id="6-getactualmaximumint-field">6. getActualMaximum(int field)</h1>
<p>返回field的最大值，例如，如果filed是Calendar.MONTH，这个月是7月的话，将会返回31，因为这个月有31天。</p>
<p>与这个相反的有：getActualMinimum(int field)</p>
<pre><code class="language-java">c.getActualMaximum(Calendar.DAY_OF_YEAR); //一年的天数，返回366
</code></pre>
]]></content>
    </entry>
</feed>