{"posts":[{"title":"使用RaiDrive在window平台上挂载google drive","content":"1.在raidrive界面添加google drive即可 2.因为raidrive不支持sock5，即在使用ssr进行科学上网时，会显示挂载失败，所以这里建议使用55tap，因为55tap早已经停止更新，所以提供了某大佬的下载地址https://down.moerats.com/55Tap/。(地址已失效) 3.将55tap的模式选择为不代理中国ip，并添加一个ss/ssr代理。保存并使用即可。 4.保存激活即可 ","link":"https://wutongsuimeng.github.io/post/shi-yong-raidrive-zai-window-ping-tai-shang-gua-zai-google-drive/"},{"title":"修复grub引导","content":"linux引导报错,在启动linux时,进入了grub rescue. 修复步骤: 1.确定系统的boot分区,我的在(hd0,gpt6),用ls查看 2.root=(hd0,gpt6) 3.确定boot分区是单独分区还是不单独分区 单独分区:prefix=(hd0,gpt6)/grub 不单独分区:prefix=(hd0,gpt6)/boot/grub 4.insmod normal 5.normal 通过以上步骤便能进入系统 6.进入系统后,要进行grub的修复 sudo update-grub 7.sudo grub-install /dev/sda (sda表示的是你的硬盘号码,不要指定号码,例如sda1之类的) 注:在grub rescue下,用ls root可以查看boot分区; 如果不知道哪个是boot分区,可以一个一个分区找,例如ls (hd0,gpt6),找到文件系统是ext2的.如果/boot不是单独分区,则用ls (hd0,gpt6)/boot找是否存在这个文件夹;如果是单独分区 ,则可以用ls (hd0,gpt6)/grub找,如果出现了grub.cfg的文件,则证明找到了boot分区 ","link":"https://wutongsuimeng.github.io/post/xiu-fu-grub-yin-dao/"},{"title":"启动vue应用","content":"一. 使用可视化启动应用 在cmd输入命令vue ui启动vue可视化界面。 在任务的serve的运行启动应用。 二. 使用命令行启动 在含有node_modules目录的目录下打开cmd，使用命令npm run serve 三. 启动应用时碰到的问题 1. 报错npm ERR! missing script:dev 因为是直接git下来的项目，所以直接去运行npm run dev命令时报错： npm ERR! missing script:dev **解决：**去看文件package.json，文件有如下代码： &quot;scripts&quot;: { &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot; }, 看到并没有dev，所以才会报错，但是可以使用serve，所以再次在目录运行命令npm run serve，便运行成功了。 2. 报错npm 报错：npm ERR! missing script: start npm ERR! A complete log of this run can be found in: npm ERR! 去看了一下，发现目录下没有node_modules目录，所以需要重新运行命令cnpm install和cnpm run build命令，重新安装依赖模块，生成node_modules目录和dist目录。 3. 报错Error while running taskwith message'spawn vue-cli-service ENOENT' 把node_modules目录删除，重新生成依赖模块。 ","link":"https://wutongsuimeng.github.io/post/qi-dong-vue-ying-yong/"},{"title":"使用JavaMail发送邮件","content":"javaMail提供了发送邮件所需的api。 本文使用freemarker创建邮件模板。 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 在application.yml中配置发送邮件信息 不建议使用outlook邮箱，因为会报错并导致outlook邮箱被锁定。需要手机验证解绑定。 使用新浪邮箱需要打开stmp服务，地址为smtp.163.com，端口为25。其他邮箱类似，其中qq邮箱需要授权码代替密码使用。 username是登录时使用的用户名，不一定是邮箱地址。 spring: mail: host: smtp.163.com port: 25 protocol: smtp username: xxx password: xxx default-encoding: utf-8 properties: mail: smtp: auth: true starttls: enable: true required: true 可能会导致的错误消息： 1. smtp.SMTPSendFailedException: 553 Mail from must equal authorized user 解决：需要登录邮箱的用户与发信人一致。意思是 helper.setFrom(&quot;xxx&quot;); 要与你配置的用户电子邮件一致 2. javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful 意思是用户名或密码错误。 使用freemarker创建邮件模板 新建一个ftl文件，放在了resources/static/ftl目录下，命名为employee.ftl。 可以使用html代码编写，使用${}表示动态指令，能随时更新。 &lt;p&gt;你好，${name}同学，恭喜你加入本公司，这是你的工作id${workID}&lt;/p&gt; 使用setClassLoaderForTemplateLoading设置模板文件地址 getTemplate用来获取模板 Configuration cfg=new Configuration(Configuration.VERSION_2_3_0); //新建一个配置 cfg.setClassLoaderForTemplateLoading(ClassLoader.getSystemClassLoader(),&quot;static/ftl/&quot;); Template emailTemplate=cfg.getTemplate(&quot;employee.ftl&quot;); 创建电子邮件并发送 注入JavaMailSender @Autowired private JavaMailSender mailSender; Map&lt;String,Object&gt; model=new HashMap&lt;&gt;(); model.put(&quot;name&quot;,employee.getName()); model.put(&quot;workID&quot;,employee.getWorkID()); MimeMessage mimeMessage=mailSender.createMimeMessage(); MimeMessageHelper helper=new MimeMessageHelper(mimeMessage,true); helper.setFrom(&quot;xxx&quot;); //设置发信人地址 helper.setTo(employee.getEmail()); //收信人地址 helper.setSubject(&quot;入职书&quot;); //设置主题 helper.setText(&quot;入职书&quot;, FreeMarkerTemplateUtils.processTemplateIntoString(emailTemplate,model)); //设置邮件内容 mailSender.send(mimeMessage); //发送邮件 完整代码 Service层 import freemarker.template.Configuration; import freemarker.template.Template; import freemarker.template.TemplateException; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.mail.javamail.JavaMailSender; import org.springframework.mail.javamail.MimeMessageHelper; import org.springframework.stereotype.Service; import org.springframework.ui.freemarker.FreeMarkerTemplateUtils; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import java.io.IOException; import java.util.HashMap; import java.util.Map; @Service(&quot;EmailService&quot;) public class EmailService { @Autowired private JavaMailSender mailSender; public void send(Employee employee) throws IOException, MessagingException, TemplateException { Configuration cfg=new Configuration(Configuration.VERSION_2_3_0); cfg.setClassLoaderForTemplateLoading(ClassLoader.getSystemClassLoader(),&quot;static/ftl/&quot;); Template emailTemplate=cfg.getTemplate(&quot;employee.ftl&quot;); Map&lt;String,Object&gt; model=new HashMap&lt;&gt;(); model.put(&quot;name&quot;,employee.getName()); model.put(&quot;workID&quot;,employee.getWorkID()); MimeMessage mimeMessage=mailSender.createMimeMessage(); MimeMessageHelper helper=new MimeMessageHelper(mimeMessage,true); helper.setFrom(&quot;xxx&quot;); helper.setTo(employee.getEmail()); helper.setSubject(&quot;入职书&quot;); helper.setText(&quot;入职书&quot;, FreeMarkerTemplateUtils.processTemplateIntoString(emailTemplate,model)); mailSender.send(mimeMessage); } } Controller层 @Resource private EmailService emailService; emailService.send(employee); ","link":"https://wutongsuimeng.github.io/post/shi-yong-javamail-fa-song-you-jian/"},{"title":"Calendar类","content":"1. Calendar.getInstance() 获取当前Calendar对象实例 2. add(int field, int amount) field是指需要获取的字段的值，对field根据当前日历增加或减少amount。 field分为： YEAR 年 MONTH 月( 0 到 11) WEEK_OF_YEAR 一年周数 WEEK_OF_MONTH 一个月周数 DAY_OF_MONTH 一个月天数，从1开始 DAY_OF_YEAR 一年的天数 。。。 例如： Calendar c=Calendar.getInstance(); c.add(Calendar.MONTH,1); //会在当前日期的月增加1，例如当前是7月，那么就会输出8月 Date d=c.getTime(); 3. set(int field, int value) 设置field为value，其他不变。 例如： Calendar c=Calendar.getInstance(); c.set(Calendar.MONTH,1); //将当前日期的月设置为1，例如现在是Sun **Jul** 12 15:19:47 CST 2020，那么将会输出Wed **Feb** 12 15:19:47 CST 2020 Date d=c.getTime(); 4. get(int field) 获取当前field的值。 c.get(Calendar.MONTH); //返回当前月数，例如现在是7月，那返回6 5. getTime() 返回一个Date属性。 6. getActualMaximum(int field) 返回field的最大值，例如，如果filed是Calendar.MONTH，这个月是7月的话，将会返回31，因为这个月有31天。 与这个相反的有：getActualMinimum(int field) c.getActualMaximum(Calendar.DAY_OF_YEAR); //一年的天数，返回366 ","link":"https://wutongsuimeng.github.io/post/calendar-lei/"}]}