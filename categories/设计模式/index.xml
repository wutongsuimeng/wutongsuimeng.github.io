<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on 梧桐碎梦</title>
    <link>https://wutongsuimeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on 梧桐碎梦</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 28 May 2023 00:23:43 +0800</lastBuildDate><atom:link href="https://wutongsuimeng.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>备忘录模式</title>
      <link>https://wutongsuimeng.github.io/post/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 28 May 2023 00:23:43 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;备忘录模式的定义是：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。&lt;/p&gt;
&lt;p&gt;该模式允许生成对象状态的快照和将其还原，主要用于撤销与重做功能的实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>中介者模式</title>
      <link>https://wutongsuimeng.github.io/post/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 21 May 2023 14:24:34 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;中介者模式的定义是：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显式地相互作用，从而使其耦合松散，而且可以独立地改变它
们之间的交互。&lt;/p&gt;
&lt;p&gt;中介者模式适合于组件之间过于耦合而不方便修改的情况。因为中介者模式强制组件之间只通过中介者交互，而不是组件之间直接交互，避免组件之间相互依赖紧密耦合，方便于修改。类所拥有的依赖关系越少， 就越易于修改、 扩展或复用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://wutongsuimeng.github.io/post/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 21 May 2023 13:41:47 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;责任链模式的定义是：使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。&lt;/p&gt;
&lt;p&gt;责任链模式适合于请求需要经过多个处理器，并被其中一个或多个处理器执行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>访问者模式</title>
      <link>https://wutongsuimeng.github.io/post/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 May 2023 11:09:16 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;访问者模式的定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。&lt;/p&gt;
&lt;p&gt;简单来说就是，就是将算法与其所作用的对象隔离开来，在不对原有类做出太多改动的情况下将新的行为封装到访问者中。在此模式中，不变的是原有类的结构，变的是功能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>模板方法模式</title>
      <link>https://wutongsuimeng.github.io/post/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 13 May 2023 09:35:57 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;模板方法的定义是：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;简单来说，就是定义好一个算法的骨架，算法的具体实现由子类去实现。在这个算法中，不变的是算法的结构，变化的是算法的具体实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>迭代器模式</title>
      <link>https://wutongsuimeng.github.io/post/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 07 May 2023 11:22:34 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;迭代器模式的定义：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://wutongsuimeng.github.io/post/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 07 May 2023 10:33:01 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;策略模式的定义是：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。&lt;/p&gt;
&lt;p&gt;策略模式通过将不同的实现算法抽取到不同的策略类中，并定义一个通用的策略接口。在上下文类中会通过全局变量存储每个策略的引用，当客户端调用上下文方法时，上下文会将工作委派给实际上的策略去执行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>https://wutongsuimeng.github.io/post/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 29 Apr 2023 10:33:35 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：使用共享对象可有效地支持大量的细粒度的对象。&lt;/p&gt;
&lt;p&gt;其实就是通过共享相同的对象来减少内存的使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://wutongsuimeng.github.io/post/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 29 Apr 2023 09:54:56 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供了一个高层次的接口，使得子系统更易于使用。&lt;/p&gt;
&lt;p&gt;简单来说就是外观模式能为程序库、 框架或其他复杂类提供一个简单的接口，客户端仅通过这个接口与子系统进行交互。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>组合模式</title>
      <link>https://wutongsuimeng.github.io/post/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 22 Apr 2023 11:35:08 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：将对象组合成树形结构以表示“部分 - 整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;p&gt;组合模式适合于树形数据结构，使用时可以应用多态或者递归处理树形数据结构。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>https://wutongsuimeng.github.io/post/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 22 Apr 2023 10:27:55 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。&lt;/p&gt;
&lt;p&gt;本质上来说，是通过组合或聚合，将对象包含于装饰类里，从而增添新的行为。装饰类实现了与对象相同的接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://wutongsuimeng.github.io/post/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 16 Apr 2023 17:16:19 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：将抽象和实现解耦，使得两者可以独立地变化。&lt;/p&gt;
&lt;p&gt;桥接模式可以将一系列密切关联的类拆分成抽象与实现两个独立的层次，以实现抽象与实现的解耦，抽象和实现可以独立变化，而不会相互影响。抽象与实现一般通过组合实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>https://wutongsuimeng.github.io/post/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 16 Apr 2023 14:00:35 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/p&gt;
&lt;p&gt;适配器模式能使得接口互不兼容的对象能相互合作。适合于希望使用某个类， 但是其接口与已有的代码不兼容的情况。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://wutongsuimeng.github.io/post/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 16 Apr 2023 11:20:09 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。&lt;/p&gt;
&lt;p&gt;观察者模式允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>命令模式</title>
      <link>https://wutongsuimeng.github.io/post/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 16 Apr 2023 10:26:08 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中。&lt;/p&gt;
&lt;p&gt;java 中的 &lt;code&gt;Runnable&lt;/code&gt; 接口使用的就是命令模式。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>https://wutongsuimeng.github.io/post/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 09 Apr 2023 22:20:58 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/p&gt;
&lt;p&gt;原型模式将克隆过程委派给被克隆的实际对象。 该模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。在java中是 &lt;code&gt;Cloneable&lt;/code&gt; 接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>构建器模式</title>
      <link>https://wutongsuimeng.github.io/post/%E6%9E%84%E5%BB%BA%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 09 Apr 2023 12:09:16 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E6%9E%84%E5%BB%BA%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;p&gt;该模式适合于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对于构造复杂，或者构造函数参数很多的对象。&lt;/li&gt;
&lt;li&gt;通过复用相同的构造代码，生成不同的产品。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://wutongsuimeng.github.io/post/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 08 Apr 2023 11:03:58 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
单例模式能保证一个类只有一个实例。实现方法是通过使用 &lt;code&gt;private static&lt;/code&gt; 来保存实例变量，使用 &lt;code&gt;private&lt;/code&gt; 修饰默认构造方法，避免通过 &lt;code&gt;new&lt;/code&gt; 创建多个实例。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>工厂模式</title>
      <link>https://wutongsuimeng.github.io/post/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 02 Apr 2023 18:11:12 +0800</pubDate>
      
      <guid>https://wutongsuimeng.github.io/post/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;对象统一由工厂返回一个抽象接口。子类通过实现工厂的抽象接口，实现具体的代码逻辑。
作用：将对象的创建和使用分离解耦。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
